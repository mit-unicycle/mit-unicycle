{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reaction Wheel Robot Project Introduction Welcome to the EPFL Reaction Wheel Robot Project which was realized by a team of 5 Computer Science students during the 2023 summer semester and took 8 weeks from start to finish. Through this complete documentation, we will guide you through the manufacturing and software development process of the robot. You can find all of the code and the CAD designs we used here: github.com/mit-unicycle Here are the Notion Pages we used to store information: Items to buy , Design , Setup guides Team members: Bruno Lazarini Sigg , David Farah , Vlad Dancau , Adrien Jean Deschenaux , Yohan Max Abehssera Motivation The motivation behind the EPFL Reaction Wheel Robot Project stems from our fascination with robotic systems and the desire to explore the principles of balance and stabilization. By constructing a robot that relies on reaction wheels, we aim to delve into the underlying physics and engineering concepts involved in maintaining stability. Our project presents a unique opportunity to combine theoretical knowledge with hands-on experience in robotics. We believe that understanding the intricate interplay between mechanics, electronics, and software is crucial for tackling complex real-world challenges in the field. Furthermore, by documenting our journey, we hope to contribute to the growing body of knowledge and inspire others to explore similar projects. We aim to provide clear instructions, explanations, and insights that empower individuals to embark on their own robotic endeavors. Project Description Our goal is to build a robot that can stabilize itself using reaction wheels. Our original milestones were: Build a prototype with only one axis of freedom . It allows us to learn how to make it work and experiment. Build a prototype with 2 axis of freedom and 2 reaction wheels . It should be able to balance on a single point of contact with the ground. Add a wheel on the bottom that would allow it to move. Although, due to issues we will discuss further and the lack of time, we couldn't complete all of them. Technical Overview In order to balance a such a device, we must apply real-time corrections to the tilt of the system. How are we going to produce the necessary force required to stabilize the robot? The answer is by using reaction wheels . A reaction wheel is a type of flywheel used primarily by spacecraft for attitude control without using fuel for rockets or other reaction devices. They are particularly useful when the spacecraft must be rotated by very small amounts, such as keeping a telescope pointed at a star, as they can generate a torque that can be precisely controlled. The project can be broken down into three main categories: Mechanical components and structure Electronics (ESC, actuator, gyroscope/accelerometer, microcontroller, ...) Software (Controller, FSM, fusion algorithms for angle, Filters, ...) In this documentation, we will explain how we built each one of them as well as the problems we faced and their solutions. Videos Challenges and Recommendations When we decided on this project, we didn't think we would encounter so many challenges. But it turned out to be a lot more difficult than we expected. If you would like to try and build a similar robot, we hope that this section will help you avoid the same mistakes we made and help make it easier. Here are some general rules of thumb: The lighter the better . The more mass you add, the harder it will be to balance the robot, and the power you need grows rapidly. This brings a lot of complications: heat, size, vibrations, mechanical complexity, power draw, structural integrity to name a few. If you can't find affordable brushless options such as the Nidec24H or Gimball motors which have integrated controllers and position sensors, then go with brushed motors. They will be much cheaper and easier to control. If you do chose a brushless route, be sure to get a sensored setup and do not to cheap out on the ESC , as it is the most important part of the build. We recommend not getting a \"black box\" ESC like we did at first by using an RC car's ESC, because we couldn't control the motor accurately which set us back 4 weeks with lots of frustration. If you can avoid mechanical complexity such as belts, gears, and pulleys, do so. They add a lot of failing points, vibrations, noise and friction which make everything harder. But be sure your motor has enough torque for your system before ruling them out. Be sure your processor is fast enough for the task and your IMU functions correctly under all circumstances before proceeding with the build. You can read more about the challenges we had on the Challenges page . Safety Considerations The project involves working with mechanical components, electronics, and software. It is important to be aware of potential hazards and take necessary precautions to ensure the safety of individuals involved in the project. Below are some safety considerations and the safety measures implemented. Hardware measures , such as covers for fingers, protection for the flywheel to prevent it from hitting the ground while spinning, and a handle to make the robot easier to hold while tuning Software measures , such as a safety angle threshold that disables the motor once a certain angle is reached, a physical button that allows us to rapidly disable it (we are using the flash button), and limitations to the max RPM of the motors Conclusion In summary, the completion of this ambitious eight-week project marks a significant milestone in our journey, even if we did not manage to make the two axes robot fully balance due to the lack of time. As we reflect on the challenges encountered throughout the process, including the instability of angle measurements, the meticulous and time-consuming tuning of the PID controller, and occasional conflicts arising from different opinions, we recognize the invaluable lessons learned and the growth we have achieved as a team. Undoubtedly, numerous late nights were dedicated to refining and perfecting our self-balancing robot. There were moments of uncertainty when the success seemed uncertain. Although this project was a very difficult one, in the end, we pushed through with determination and managed to get a robot that balances itself. The feeling of seeing the result of countless hours of work cannot be expressed in words Moreover, beyond the technical accomplishments, this project helped us develop on a personal and professional level. The collaborative nature of this project encouraged us to work in team, allowing us to appreciate the importance of communication and cooperation. We gained hands-on experience in various areas, from using CAD software, learning the operation of mechanical tools, and using technologies like 3D printing and laser cutting to bring our ideas to life. Not only that, but we also improved our programming skills and gained some insight into the field of robotics. In conclusion, we proudly present this self-balancing robot as a testament to our dedication, hard work, and determination. It is with great satisfaction and gratification that we look back on the solved challenges and the knowledge acquired during the process. We hope that this project, will serve as an inspiration to future students in IC. We encourage them to embark on the CS-358 course, which wil help them develop skills on the many fields mentioned.","title":"Home"},{"location":"#reaction-wheel-robot-project","text":"","title":"Reaction Wheel Robot Project"},{"location":"#introduction","text":"Welcome to the EPFL Reaction Wheel Robot Project which was realized by a team of 5 Computer Science students during the 2023 summer semester and took 8 weeks from start to finish. Through this complete documentation, we will guide you through the manufacturing and software development process of the robot. You can find all of the code and the CAD designs we used here: github.com/mit-unicycle Here are the Notion Pages we used to store information: Items to buy , Design , Setup guides Team members: Bruno Lazarini Sigg , David Farah , Vlad Dancau , Adrien Jean Deschenaux , Yohan Max Abehssera","title":"Introduction"},{"location":"#motivation","text":"The motivation behind the EPFL Reaction Wheel Robot Project stems from our fascination with robotic systems and the desire to explore the principles of balance and stabilization. By constructing a robot that relies on reaction wheels, we aim to delve into the underlying physics and engineering concepts involved in maintaining stability. Our project presents a unique opportunity to combine theoretical knowledge with hands-on experience in robotics. We believe that understanding the intricate interplay between mechanics, electronics, and software is crucial for tackling complex real-world challenges in the field. Furthermore, by documenting our journey, we hope to contribute to the growing body of knowledge and inspire others to explore similar projects. We aim to provide clear instructions, explanations, and insights that empower individuals to embark on their own robotic endeavors.","title":"Motivation"},{"location":"#project-description","text":"Our goal is to build a robot that can stabilize itself using reaction wheels. Our original milestones were: Build a prototype with only one axis of freedom . It allows us to learn how to make it work and experiment. Build a prototype with 2 axis of freedom and 2 reaction wheels . It should be able to balance on a single point of contact with the ground. Add a wheel on the bottom that would allow it to move. Although, due to issues we will discuss further and the lack of time, we couldn't complete all of them.","title":"Project Description"},{"location":"#technical-overview","text":"In order to balance a such a device, we must apply real-time corrections to the tilt of the system. How are we going to produce the necessary force required to stabilize the robot? The answer is by using reaction wheels . A reaction wheel is a type of flywheel used primarily by spacecraft for attitude control without using fuel for rockets or other reaction devices. They are particularly useful when the spacecraft must be rotated by very small amounts, such as keeping a telescope pointed at a star, as they can generate a torque that can be precisely controlled. The project can be broken down into three main categories: Mechanical components and structure Electronics (ESC, actuator, gyroscope/accelerometer, microcontroller, ...) Software (Controller, FSM, fusion algorithms for angle, Filters, ...) In this documentation, we will explain how we built each one of them as well as the problems we faced and their solutions.","title":"Technical Overview"},{"location":"#videos","text":"","title":"Videos"},{"location":"#challenges-and-recommendations","text":"When we decided on this project, we didn't think we would encounter so many challenges. But it turned out to be a lot more difficult than we expected. If you would like to try and build a similar robot, we hope that this section will help you avoid the same mistakes we made and help make it easier. Here are some general rules of thumb: The lighter the better . The more mass you add, the harder it will be to balance the robot, and the power you need grows rapidly. This brings a lot of complications: heat, size, vibrations, mechanical complexity, power draw, structural integrity to name a few. If you can't find affordable brushless options such as the Nidec24H or Gimball motors which have integrated controllers and position sensors, then go with brushed motors. They will be much cheaper and easier to control. If you do chose a brushless route, be sure to get a sensored setup and do not to cheap out on the ESC , as it is the most important part of the build. We recommend not getting a \"black box\" ESC like we did at first by using an RC car's ESC, because we couldn't control the motor accurately which set us back 4 weeks with lots of frustration. If you can avoid mechanical complexity such as belts, gears, and pulleys, do so. They add a lot of failing points, vibrations, noise and friction which make everything harder. But be sure your motor has enough torque for your system before ruling them out. Be sure your processor is fast enough for the task and your IMU functions correctly under all circumstances before proceeding with the build. You can read more about the challenges we had on the Challenges page .","title":"Challenges and Recommendations"},{"location":"#safety-considerations","text":"The project involves working with mechanical components, electronics, and software. It is important to be aware of potential hazards and take necessary precautions to ensure the safety of individuals involved in the project. Below are some safety considerations and the safety measures implemented. Hardware measures , such as covers for fingers, protection for the flywheel to prevent it from hitting the ground while spinning, and a handle to make the robot easier to hold while tuning Software measures , such as a safety angle threshold that disables the motor once a certain angle is reached, a physical button that allows us to rapidly disable it (we are using the flash button), and limitations to the max RPM of the motors","title":"Safety Considerations"},{"location":"#conclusion","text":"In summary, the completion of this ambitious eight-week project marks a significant milestone in our journey, even if we did not manage to make the two axes robot fully balance due to the lack of time. As we reflect on the challenges encountered throughout the process, including the instability of angle measurements, the meticulous and time-consuming tuning of the PID controller, and occasional conflicts arising from different opinions, we recognize the invaluable lessons learned and the growth we have achieved as a team. Undoubtedly, numerous late nights were dedicated to refining and perfecting our self-balancing robot. There were moments of uncertainty when the success seemed uncertain. Although this project was a very difficult one, in the end, we pushed through with determination and managed to get a robot that balances itself. The feeling of seeing the result of countless hours of work cannot be expressed in words Moreover, beyond the technical accomplishments, this project helped us develop on a personal and professional level. The collaborative nature of this project encouraged us to work in team, allowing us to appreciate the importance of communication and cooperation. We gained hands-on experience in various areas, from using CAD software, learning the operation of mechanical tools, and using technologies like 3D printing and laser cutting to bring our ideas to life. Not only that, but we also improved our programming skills and gained some insight into the field of robotics. In conclusion, we proudly present this self-balancing robot as a testament to our dedication, hard work, and determination. It is with great satisfaction and gratification that we look back on the solved challenges and the knowledge acquired during the process. We hope that this project, will serve as an inspiration to future students in IC. We encourage them to embark on the CS-358 course, which wil help them develop skills on the many fields mentioned.","title":"Conclusion"},{"location":"building/assembly/","text":"Assembly Instructions In this page you'll find the information about the building of the first and second prototype, you'll need to have the following elements with you : For the one axis prototype : 1x The main plate for one axis 1x the motor mount 1 meter M8 rods M3 screws M3 nuts 1x Motor pulley 1x Motor coupler 1x GT2 7 times reductions with plates 3x ball bearings Instruction to build the first prototype : Here's a small gif that shows help you to visualize how is assembled the first prototype : On this gif there is not nuts or screws, therefore we'll explain here where you should put them. first you'll need four M3 screws, nuts and washers to fix the motor mount to the plate. To securely fasten the motor coupler with the motor pulley, you will need to use M3 screws and nuts. Similarly, for the assembly of the big pulley, pulley plate, spacer plates, and reaction wheel, you can use M3 screws and nuts to join them together. To securely tighten the long threaded rods, you will require four M8 nuts and washers. These will be used to fasten the two long threaded rods with the main platform, with one set of four nut and washer placed on the top face and the other set on the bottom. Similarly, you will need another set of four M8 nuts and washers to align and secure the motor shaft holder with the pulley and ball bearing, following the same concept as with the main plate. Additionally, four M8 nuts and washers will be used to fix the motor wheel holder in place. You should also use nuts to tension the ball bearing. For each ball bearing, you should have a nut placed against it to apply tension. To enhance the friction of the model, it is recommended to glue rubber bands onto the bottom surface. This will increase the grip and traction, providing better stability and reducing slippage. You can also choose how many M3 screws you want on the reaction wheel, keeping in mind that the more you put, the bigger the moment of inertia will be.","title":"Assembly Instructions"},{"location":"building/assembly/#assembly-instructions","text":"In this page you'll find the information about the building of the first and second prototype, you'll need to have the following elements with you : For the one axis prototype : 1x The main plate for one axis 1x the motor mount 1 meter M8 rods M3 screws M3 nuts 1x Motor pulley 1x Motor coupler 1x GT2 7 times reductions with plates 3x ball bearings","title":"Assembly Instructions"},{"location":"building/assembly/#instruction-to-build-the-first-prototype","text":"Here's a small gif that shows help you to visualize how is assembled the first prototype : On this gif there is not nuts or screws, therefore we'll explain here where you should put them. first you'll need four M3 screws, nuts and washers to fix the motor mount to the plate. To securely fasten the motor coupler with the motor pulley, you will need to use M3 screws and nuts. Similarly, for the assembly of the big pulley, pulley plate, spacer plates, and reaction wheel, you can use M3 screws and nuts to join them together. To securely tighten the long threaded rods, you will require four M8 nuts and washers. These will be used to fasten the two long threaded rods with the main platform, with one set of four nut and washer placed on the top face and the other set on the bottom. Similarly, you will need another set of four M8 nuts and washers to align and secure the motor shaft holder with the pulley and ball bearing, following the same concept as with the main plate. Additionally, four M8 nuts and washers will be used to fix the motor wheel holder in place. You should also use nuts to tension the ball bearing. For each ball bearing, you should have a nut placed against it to apply tension. To enhance the friction of the model, it is recommended to glue rubber bands onto the bottom surface. This will increase the grip and traction, providing better stability and reducing slippage. You can also choose how many M3 screws you want on the reaction wheel, keeping in mind that the more you put, the bigger the moment of inertia will be.","title":"Instruction to build the first prototype :"},{"location":"building/components/","text":"Components Used In this section, we will list the components we used and the reason for choosing them. List of Components 1x NodeMCU esp8266 1x MPU6050 Gyroscope and Accelerometer Module 2x Dilwe 540 Sensored Brushless DC Motor 2x FSESC 4.12 50A Motor Driver 1x 3S Lipo battery 2x GT2 9mm wide, 700mm long timing belt 2x 1m long, M8 threaded rod 11x M8 bolts, washers, O-rings and nuts for the structure of the robot 16x M6 bolts and nuts for increasing the moment of inertia of the reaction wheel 4x M3 \"Grub\" screws for the motor coupler Zipties, elastic bands, double sided tape and velcro NodeMCU esp8266 We chose to use the NodeMCU esp8266 for various reasons. First and foremost, the NodeMCU has a maximal clock speed of 160 MHz. In comparison to the Arduino Uno's 16 MHz, the NodeMCU is extremely fast. This suits our robot well, since for it to balance, it must react as quickly as possible. Moreover, the NodeMCU has a WiFi card embedded on it. This is really convenient for tuning the PID parameters, as it allows us to avoid flashing the nodeMCU every time we change change the parameters. MPU6050 Gyroscope and Accelerometer The MPU6050 is a cheap and readily available gyroscope and accelerometer. It comes with a built-in DMP processor that allows for the fusion of the gyroscope and accelerometer data for obtaining the roll/pitch/yaw of the sensor. As we discuss in the challenges , it was not easy to get it to work properly. Dilwe 540 Sensored Brushless DC Motor (13.5T) This motor was our best option for the following reasons. It is a sensored motor, this means ESC to accurately control it and have good torque at low RPMs (this is very important) It was the cheapes option of it's kind and so was able to fit our budget It has enough power to do what we need it to do It has a lot of inconveniences though, which we dicuss further here FSESC 4.12 50A Motor Driver The FSESC 4.12 is based on the VESC project , an excellent Open Source ESC platform that is often used in electric skateboards, bikes and many more applications. It comes with a software to extensively tune the behavior of the motor driver. We can also connect the motor's hall sensors to it, allowing for very precise control at all speeds, and communicate via UART at high speeds.","title":"Components Used"},{"location":"building/components/#components-used","text":"In this section, we will list the components we used and the reason for choosing them.","title":"Components Used"},{"location":"building/components/#list-of-components","text":"1x NodeMCU esp8266 1x MPU6050 Gyroscope and Accelerometer Module 2x Dilwe 540 Sensored Brushless DC Motor 2x FSESC 4.12 50A Motor Driver 1x 3S Lipo battery 2x GT2 9mm wide, 700mm long timing belt 2x 1m long, M8 threaded rod 11x M8 bolts, washers, O-rings and nuts for the structure of the robot 16x M6 bolts and nuts for increasing the moment of inertia of the reaction wheel 4x M3 \"Grub\" screws for the motor coupler Zipties, elastic bands, double sided tape and velcro","title":"List of Components"},{"location":"building/components/#nodemcu-esp8266","text":"We chose to use the NodeMCU esp8266 for various reasons. First and foremost, the NodeMCU has a maximal clock speed of 160 MHz. In comparison to the Arduino Uno's 16 MHz, the NodeMCU is extremely fast. This suits our robot well, since for it to balance, it must react as quickly as possible. Moreover, the NodeMCU has a WiFi card embedded on it. This is really convenient for tuning the PID parameters, as it allows us to avoid flashing the nodeMCU every time we change change the parameters.","title":"NodeMCU esp8266"},{"location":"building/components/#mpu6050-gyroscope-and-accelerometer","text":"The MPU6050 is a cheap and readily available gyroscope and accelerometer. It comes with a built-in DMP processor that allows for the fusion of the gyroscope and accelerometer data for obtaining the roll/pitch/yaw of the sensor. As we discuss in the challenges , it was not easy to get it to work properly.","title":"MPU6050 Gyroscope and Accelerometer"},{"location":"building/components/#dilwe-540-sensored-brushless-dc-motor-135t","text":"This motor was our best option for the following reasons. It is a sensored motor, this means ESC to accurately control it and have good torque at low RPMs (this is very important) It was the cheapes option of it's kind and so was able to fit our budget It has enough power to do what we need it to do It has a lot of inconveniences though, which we dicuss further here","title":"Dilwe 540 Sensored Brushless DC Motor (13.5T)"},{"location":"building/components/#fsesc-412-50a-motor-driver","text":"The FSESC 4.12 is based on the VESC project , an excellent Open Source ESC platform that is often used in electric skateboards, bikes and many more applications. It comes with a software to extensively tune the behavior of the motor driver. We can also connect the motor's hall sensors to it, allowing for very precise control at all speeds, and communicate via UART at high speeds.","title":"FSESC 4.12 50A Motor Driver"},{"location":"building/manufacturing/","text":"Manufacturing Preliminaries In this section you will find the information related to the realization of the 3D designs,the specification about the printing of our parts and the blueprints of the parts. This section will be separated in 3 parts : the first presenting the parts that can be used for both one and two axis, then the parts specific to the one axis design and finally the parts for the two axis model. For the designs we used Fusion 360 and Prusa 3D printers . Note that every dimension reported on the blueprint are given in millimeters (mm) . Common parts 1.1 The reaction wheel and the spacers 1.2 The teethed pulley 1.3 The motor coupler 1.4 The motor pulley First prototype 2.1 Main platform 2.2 Motor shaft holder 2.3 Reaction wheel holder ======= How to design a GT-2 pulley with Fusion 360 Common parts : 2.1 The reaction wheel and the spacers 2.2 The teethed pulley 2.3 The motor coupler 2.4 The motor pulley First prototype 3.1 Main platform 3.2 Motor shaft holder 3.3 Reaction wheel holder Second prototype : 4.1 Main platform 4.1 Main platform 4.2 The Stick 4.3 the motor support 4.4 the reaction wheel holder how to design a GT-2 parametric design of a pulley What is a GT-2 pulley ? A GT-2 pulley is a type of standard for belts and pulleys, it is defined mostly by the pitch of the teeth and the distance between the edges of two teeth. Here's the description of the parameters we're interested in for designing the teethed pulley. the parameter R1 correspond to the inner pitch of the teeth of our pulley, we can think about it as if we small circles of this diameter at the same position at both side of one of the pulley's teeth. the parameter R3 correspond to the tooth radius, in the case of the design of the pulley. The parameter P is really important since it is the distance between two teeth ( in mm ). Therefore the diameter is defined by : $$D = \\frac{(P*N)}{Pi} $$ $N$ : The number of teeth ( must be an integer), $D$ : The diameter, $P$ : The the distance between two teeth, given by the standards of the pulleys If we still want to be able to \"choose\" the diameter, then with basic algebra find the number of teeth needed for the desired diameter: $$ N = \\frac{D \\pi}{P}$$ To create a parametric design for a GT2 pulley, you can refer to the video tutorial mentioned. It provides a helpful guide to follow and assists in achieving the desired outcome : To create a parametric design for a GT2 pulley, you can refer to the video tutorial mentioned. It provides a helpful guide to follow and assists in achieving the desired outcome : 2. Common parts 2.1 The reaction wheel and the spacers The reaction wheel In order to achieve the maximum moment of inertia for the reaction wheel, our objective was to maximize the diameter of the wheel. Since the moment of inertia is the sum of the squared distances to the mass, the farther the mass is from the axis, the larger the moment will be. However, we faced a constraint due to the size of the printing bed of the printer we used for the distance to the axis. Our experimentation demonstrated that a wheel with a thin design could easily break if the model were to fall. This is why the model we have implemented here is highly robust and should not break, provided it is used correctly in the application of this project. Note that the reaction wheel has 32 holes for the screws used to add weight far from the axis. The most crucial aspect of printing this part is to use an appropriate perimeter setting. Increasing the perimeter setting enables us to reinforce the piece without significantly increasing the infill. It is essential for the holes where we will insert screws, nuts, and the location where the ball bearing will be placed to be sufficiently strong. This ensures that they do not break during rotation or when inserting the ball bearing. Here we used a perimeter of 4 and an infill of : The spacers As you can observe in the section explaining the assembly of the model, we needed spacers with the same inner diameter as the ball bearing to ensure a good fit between the ball bearings. The accompanying design picture, illustrates the dimensions of one of these spacers. Please note that we used spacers of various sizes, because the length of those depend on the number of spacing plates used, but we are presenting only one blueprint as the only difference lies in the height of the spacers. We used 9mm spacers, but since it's really small parts you can try to print different sized spacers. The spacing plates : In order to avoid that the belt hits the nuts from the reaction wheel while working, we needed spacer plates to increase the distance between the teethed pulley therefore we designed the spacing plates here bellow is the design and the dimensions of those spacers. we use 2 of them in the model but if needed you try to use more. In order to avoid that the belt hits the nuts from the reaction wheel while working, we needed spacer plates to increase the distance between the teethed pulley therefore we designed the spacing plates here bellow is the design and the dimensions of those spacers. we use 2 of them in the model but if needed you try to use more. 2.2. The teethed pulley We used GT-2 belts, which necessitated the design of GT-2 pulleys. To achieve this, we employed a functionality in Fusion 360 that enabled us to create parametric designs of the pulleys. This approach facilitated the rapid design of the desired pulley variations and also facilitated testing different gear reduction options. The creation of this design is explained step by steps just bellow The GT-2 pulley follows a specific standard for the teeth, which includes the pitch of the teeth on the pulleys and belts. Therefore, the parametric design of the pulley size depend on the desired number of teeth . In our specific application, the number of teeth required is determined by the desired gear reduction. For this particular printing, the most important setting to consider is the precision . Given that we are printing pulleys with small teeth, it is essential for the printing to be as accurate and precise as possible. Here we used the option : 10mm Quality preset from Prusa Slicer . To prevent the belt to skip, we need plates to help the belt stay straight in on the pulley, here's the blueprint of those plates : 2.3. Motor coupler For the motor coupler, we machined them using the tools available to us. This approach enabled us to create a high-quality coupler specifically designed for the motor we had. We were unable to find any suitable couplers for purchase online that could be delivered within a reasonable time frame, which is why we resorted to machining our own. Here's the blueprint we created for this coupler 2.4. The motor pulley : To do the gear reduction we wanted we needed to fix a small teethed pulley to the motor coupler. We needed this pulley to be small enough to avoid printing enormous pulley if we wanted to modify the gears reduction. Increasing the reduction means modifying the height of the reaction wheel it could also mean buying new belts if the diameter of the pulley is too big. The minimum diameter of the pulley (which is in fact a constraint on the number of teeth) is limited by the screws holes position of the motor coupler. 3.1 One axis bottom : As the first prototype purpose is to balance in one axis of freedom, we needed a plate where we could fit the motor, the ESC, the breadboard and the esp8266. Note that for the first prototype we did all the tests without the battery mounted. We printed this part only in PETG and glued some rubber on the bottom to add friction, but if we had had more time we would have printed this as a composite of two materials (See in the section about the balancing stick). 3.2 Motor shaft support : The motor shaft support part serves the purpose of preventing excessive tension on the motor shaft while tensioning the belt. By using this part, we can avoid putting undue strain on the motor shaft, reducing the risk of damaging or breaking the motor. Alternatively, one can utilize a threaded rod inserted into the ball bearing of the motor pulley design to achieve the desired belt tension. This method allows for greater flexibility in adjusting the tension without concerns about motor damage. P lease note that for the two-axis design, we did not use a specific piece for belt tensioning. Initially, this decision was made due to space constraints. However, during testing and experimentation, we discovered that the motor shaft support was not necessary for belt tensioning. Therefore, we found that the motor shaft support could be omitted without compromising the proper tensioning of the belt. 3.3 reaction wheel support : The part here bellow is designed to hold the threaded rod to hold the reaction wheel. 4. Second prototype : 4.1 Main platform : The design of the main plate for the two axis prototype, there were two constraint that we had to satisfy : The distance two holes separated by 144 mm (which we'll refer as : the threaded rod holes), which is the distance of the holes in the handle of this prototype. We could easily increase this distance if needed but , increasing this distance means that the wheel older becomes bigger and heavier, and increasing the weight at the top too much is something we want to avoid if possible. The place where we'll put the motors, it also depends on the threaded rods holes, since it depends on the \"two axis wheel holder\". This place is also constrained by the size of the motor, since the motors could touch each others. The small marks located next to the inserts for the motor mount are designed to serve as indicators for the motor position. While they are not strictly mandatory, they can be useful for aligning the motors at approximately the same relative position. These marks are more of a helpful guideline rather than a strict requirement. It is up to you whether you choose to include them in the design or not. You have the flexibility to determine the spacing between two of these marks according to your preference or specific needs. 4.2 The Stick : This part is the stick that serves the purpose of balancing the model. Although the design itself is relatively simple, the printing process presents a unique aspect. We encountered an issue where balancing on a stick made solely from PETG plastic was not viable due to its lack of grip, which would complicate the balancing process. Consequently, we devised a solution to print the stick using a combination of two materials. The upper part of the stick is printed using PETG plastic, while the half sphere at the end of the stick is printed using TPU plastic. We opted for TPU plastic because it is commonly used for tire prototypes, which offers improved grip properties. To achieve the composition of materials, we programmed a color change during the print process where we intended to switch to the TPU filament. Due to the difference in density between TPU and PETG, we had to make slight adjustments to the printer's head positioning to meet the specific requirements for printing TPU with Prusa printers. Note that in order to achieve a desirable texture with the TPU material, we utilized the following specific parameters (ONLY for the TPU part): Fill density : 10% Fill pattern : Gyroid Bottom solid layers : 5 Perimeters : 2 Top solid layers : 4 Considering that this is a small print, leaving the top solid layer unaltered would have reTosulted in a denser and less flexible top portion. By modifying the top solid layer, we were able to achieve the desired level of flexibility and meet our specific requirements for the print. 4.3 The Motor Support : The design of the motor support for this project is largely similar to the one used for the single-axis prototype. However, there are a few notable differences. Firstly, the holes used for attaching the motor support to the plate are positioned closer together in this design. Additionally, the base of the motor support is narrower. This modification was made to ensure that the wheel holder and the handle could remain compact, as increasing their size was something we aimed to avoid. 4.4 The reaction wheel holder : This part is specifically designed to securely hold the two reactions perpendicularly, while minimizing the distance between both wheels. The goal is to make the model as compact as possible. There are two designated positions for threaded rods vertically, which serve to connect this part with the main plate. Additionally, two other holes are provided for threaded rods to be inserted perpendicular to the part, enabling them to hold the reaction wheel in place. 4.5 The two axis handle : Note that this design of the handle is just the same design as the one axis one but with different size.","title":"Manufacturing"},{"location":"building/manufacturing/#manufacturing","text":"","title":"Manufacturing"},{"location":"building/manufacturing/#preliminaries","text":"In this section you will find the information related to the realization of the 3D designs,the specification about the printing of our parts and the blueprints of the parts. This section will be separated in 3 parts : the first presenting the parts that can be used for both one and two axis, then the parts specific to the one axis design and finally the parts for the two axis model. For the designs we used Fusion 360 and Prusa 3D printers . Note that every dimension reported on the blueprint are given in millimeters (mm) . Common parts 1.1 The reaction wheel and the spacers 1.2 The teethed pulley 1.3 The motor coupler 1.4 The motor pulley First prototype 2.1 Main platform 2.2 Motor shaft holder 2.3 Reaction wheel holder ======= How to design a GT-2 pulley with Fusion 360 Common parts : 2.1 The reaction wheel and the spacers 2.2 The teethed pulley 2.3 The motor coupler 2.4 The motor pulley First prototype 3.1 Main platform 3.2 Motor shaft holder 3.3 Reaction wheel holder Second prototype : 4.1 Main platform 4.1 Main platform 4.2 The Stick 4.3 the motor support 4.4 the reaction wheel holder","title":"Preliminaries"},{"location":"building/manufacturing/#how-to-design-a-gt-2-parametric-design-of-a-pulley","text":"What is a GT-2 pulley ? A GT-2 pulley is a type of standard for belts and pulleys, it is defined mostly by the pitch of the teeth and the distance between the edges of two teeth. Here's the description of the parameters we're interested in for designing the teethed pulley. the parameter R1 correspond to the inner pitch of the teeth of our pulley, we can think about it as if we small circles of this diameter at the same position at both side of one of the pulley's teeth. the parameter R3 correspond to the tooth radius, in the case of the design of the pulley. The parameter P is really important since it is the distance between two teeth ( in mm ). Therefore the diameter is defined by : $$D = \\frac{(P*N)}{Pi} $$ $N$ : The number of teeth ( must be an integer), $D$ : The diameter, $P$ : The the distance between two teeth, given by the standards of the pulleys If we still want to be able to \"choose\" the diameter, then with basic algebra find the number of teeth needed for the desired diameter: $$ N = \\frac{D \\pi}{P}$$ To create a parametric design for a GT2 pulley, you can refer to the video tutorial mentioned. It provides a helpful guide to follow and assists in achieving the desired outcome : To create a parametric design for a GT2 pulley, you can refer to the video tutorial mentioned. It provides a helpful guide to follow and assists in achieving the desired outcome :","title":"how to design a GT-2 parametric design of a pulley"},{"location":"building/manufacturing/#2-common-parts","text":"","title":"2. Common parts"},{"location":"building/manufacturing/#21-the-reaction-wheel-and-the-spacers","text":"The reaction wheel In order to achieve the maximum moment of inertia for the reaction wheel, our objective was to maximize the diameter of the wheel. Since the moment of inertia is the sum of the squared distances to the mass, the farther the mass is from the axis, the larger the moment will be. However, we faced a constraint due to the size of the printing bed of the printer we used for the distance to the axis. Our experimentation demonstrated that a wheel with a thin design could easily break if the model were to fall. This is why the model we have implemented here is highly robust and should not break, provided it is used correctly in the application of this project. Note that the reaction wheel has 32 holes for the screws used to add weight far from the axis. The most crucial aspect of printing this part is to use an appropriate perimeter setting. Increasing the perimeter setting enables us to reinforce the piece without significantly increasing the infill. It is essential for the holes where we will insert screws, nuts, and the location where the ball bearing will be placed to be sufficiently strong. This ensures that they do not break during rotation or when inserting the ball bearing. Here we used a perimeter of 4 and an infill of : The spacers As you can observe in the section explaining the assembly of the model, we needed spacers with the same inner diameter as the ball bearing to ensure a good fit between the ball bearings. The accompanying design picture, illustrates the dimensions of one of these spacers. Please note that we used spacers of various sizes, because the length of those depend on the number of spacing plates used, but we are presenting only one blueprint as the only difference lies in the height of the spacers. We used 9mm spacers, but since it's really small parts you can try to print different sized spacers. The spacing plates : In order to avoid that the belt hits the nuts from the reaction wheel while working, we needed spacer plates to increase the distance between the teethed pulley therefore we designed the spacing plates here bellow is the design and the dimensions of those spacers. we use 2 of them in the model but if needed you try to use more. In order to avoid that the belt hits the nuts from the reaction wheel while working, we needed spacer plates to increase the distance between the teethed pulley therefore we designed the spacing plates here bellow is the design and the dimensions of those spacers. we use 2 of them in the model but if needed you try to use more.","title":"2.1 The reaction wheel and the spacers"},{"location":"building/manufacturing/#22-the-teethed-pulley","text":"We used GT-2 belts, which necessitated the design of GT-2 pulleys. To achieve this, we employed a functionality in Fusion 360 that enabled us to create parametric designs of the pulleys. This approach facilitated the rapid design of the desired pulley variations and also facilitated testing different gear reduction options. The creation of this design is explained step by steps just bellow The GT-2 pulley follows a specific standard for the teeth, which includes the pitch of the teeth on the pulleys and belts. Therefore, the parametric design of the pulley size depend on the desired number of teeth . In our specific application, the number of teeth required is determined by the desired gear reduction. For this particular printing, the most important setting to consider is the precision . Given that we are printing pulleys with small teeth, it is essential for the printing to be as accurate and precise as possible. Here we used the option : 10mm Quality preset from Prusa Slicer . To prevent the belt to skip, we need plates to help the belt stay straight in on the pulley, here's the blueprint of those plates :","title":"2.2. The teethed pulley"},{"location":"building/manufacturing/#23-motor-coupler","text":"For the motor coupler, we machined them using the tools available to us. This approach enabled us to create a high-quality coupler specifically designed for the motor we had. We were unable to find any suitable couplers for purchase online that could be delivered within a reasonable time frame, which is why we resorted to machining our own. Here's the blueprint we created for this coupler","title":"2.3. Motor coupler"},{"location":"building/manufacturing/#24-the-motor-pulley","text":"To do the gear reduction we wanted we needed to fix a small teethed pulley to the motor coupler. We needed this pulley to be small enough to avoid printing enormous pulley if we wanted to modify the gears reduction. Increasing the reduction means modifying the height of the reaction wheel it could also mean buying new belts if the diameter of the pulley is too big. The minimum diameter of the pulley (which is in fact a constraint on the number of teeth) is limited by the screws holes position of the motor coupler.","title":"2.4. The motor pulley :"},{"location":"building/manufacturing/#31-one-axis-bottom","text":"As the first prototype purpose is to balance in one axis of freedom, we needed a plate where we could fit the motor, the ESC, the breadboard and the esp8266. Note that for the first prototype we did all the tests without the battery mounted. We printed this part only in PETG and glued some rubber on the bottom to add friction, but if we had had more time we would have printed this as a composite of two materials (See in the section about the balancing stick).","title":"3.1 One axis bottom :"},{"location":"building/manufacturing/#32-motor-shaft-support","text":"The motor shaft support part serves the purpose of preventing excessive tension on the motor shaft while tensioning the belt. By using this part, we can avoid putting undue strain on the motor shaft, reducing the risk of damaging or breaking the motor. Alternatively, one can utilize a threaded rod inserted into the ball bearing of the motor pulley design to achieve the desired belt tension. This method allows for greater flexibility in adjusting the tension without concerns about motor damage. P lease note that for the two-axis design, we did not use a specific piece for belt tensioning. Initially, this decision was made due to space constraints. However, during testing and experimentation, we discovered that the motor shaft support was not necessary for belt tensioning. Therefore, we found that the motor shaft support could be omitted without compromising the proper tensioning of the belt.","title":"3.2 Motor shaft support :"},{"location":"building/manufacturing/#33-reaction-wheel-support","text":"The part here bellow is designed to hold the threaded rod to hold the reaction wheel.","title":"3.3 reaction wheel support :"},{"location":"building/manufacturing/#4-second-prototype","text":"","title":"4. Second prototype :"},{"location":"building/manufacturing/#41-main-platform","text":"The design of the main plate for the two axis prototype, there were two constraint that we had to satisfy : The distance two holes separated by 144 mm (which we'll refer as : the threaded rod holes), which is the distance of the holes in the handle of this prototype. We could easily increase this distance if needed but , increasing this distance means that the wheel older becomes bigger and heavier, and increasing the weight at the top too much is something we want to avoid if possible. The place where we'll put the motors, it also depends on the threaded rods holes, since it depends on the \"two axis wheel holder\". This place is also constrained by the size of the motor, since the motors could touch each others. The small marks located next to the inserts for the motor mount are designed to serve as indicators for the motor position. While they are not strictly mandatory, they can be useful for aligning the motors at approximately the same relative position. These marks are more of a helpful guideline rather than a strict requirement. It is up to you whether you choose to include them in the design or not. You have the flexibility to determine the spacing between two of these marks according to your preference or specific needs.","title":"4.1 Main platform :"},{"location":"building/manufacturing/#42-the-stick","text":"This part is the stick that serves the purpose of balancing the model. Although the design itself is relatively simple, the printing process presents a unique aspect. We encountered an issue where balancing on a stick made solely from PETG plastic was not viable due to its lack of grip, which would complicate the balancing process. Consequently, we devised a solution to print the stick using a combination of two materials. The upper part of the stick is printed using PETG plastic, while the half sphere at the end of the stick is printed using TPU plastic. We opted for TPU plastic because it is commonly used for tire prototypes, which offers improved grip properties. To achieve the composition of materials, we programmed a color change during the print process where we intended to switch to the TPU filament. Due to the difference in density between TPU and PETG, we had to make slight adjustments to the printer's head positioning to meet the specific requirements for printing TPU with Prusa printers. Note that in order to achieve a desirable texture with the TPU material, we utilized the following specific parameters (ONLY for the TPU part): Fill density : 10% Fill pattern : Gyroid Bottom solid layers : 5 Perimeters : 2 Top solid layers : 4 Considering that this is a small print, leaving the top solid layer unaltered would have reTosulted in a denser and less flexible top portion. By modifying the top solid layer, we were able to achieve the desired level of flexibility and meet our specific requirements for the print.","title":"4.2 The Stick :"},{"location":"building/manufacturing/#43-the-motor-support","text":"The design of the motor support for this project is largely similar to the one used for the single-axis prototype. However, there are a few notable differences. Firstly, the holes used for attaching the motor support to the plate are positioned closer together in this design. Additionally, the base of the motor support is narrower. This modification was made to ensure that the wheel holder and the handle could remain compact, as increasing their size was something we aimed to avoid.","title":"4.3 The Motor Support :"},{"location":"building/manufacturing/#44-the-reaction-wheel-holder","text":"This part is specifically designed to securely hold the two reactions perpendicularly, while minimizing the distance between both wheels. The goal is to make the model as compact as possible. There are two designated positions for threaded rods vertically, which serve to connect this part with the main plate. Additionally, two other holes are provided for threaded rods to be inserted perpendicular to the part, enabling them to hold the reaction wheel in place.","title":"4.4 The reaction wheel holder :"},{"location":"building/manufacturing/#45-the-two-axis-handle","text":"Note that this design of the handle is just the same design as the one axis one but with different size.","title":"4.5 The two axis handle :"},{"location":"building/physics/","text":"Underlying physics In this section, we will explain the physics behind the balancing robot, and how we used it to design the robot. Physics concept In order to build a functioning balancing robot, it is really important to understand the physics that make it work. In this section, we will address this. The self-balancing capability of our robot relies on the conservation of angular momentum. When the robot tilts, the reaction wheel is accelerated in a controlled manner in order to apply a reactive torque on the system, thus countering the torque caused by gravity. By exerting an opposing force, the reaction wheel helps restore the robot to an upright position. This continuous adjustment and counteraction of tilting forces enable the robot to maintain its balance in real time. We can consider the following simplified model of an inverted pendulum: We can derive the equations of motion of the system using rotational mechanics , which will help us understand what kind of forces we are dealing with. Please check the full development for more details on notation and derivation. Here are some of the important formulas we derived: Torque: $$\\tau_w = I_s\\alpha_s - h_gMgsin(\\phi)$$ Angular acceleration: $$\\alpha_w(\\phi)=\\frac{I_s}{I_w}\\alpha_s - \\frac{h_gMgsin(\\phi)}{I_w}$$ Power: $$P_w = \\tau_w\\omega_w$$ You can find the Graphs of the equations of motion in our Desmos Project , and play around with the parameters to see how they affect the system. We found out in our initial estimations that a quite large output torque is required to stabilize the 2 axis robot with the parts that were available to us, about 2Nm and 25W of mechanical power at least, which is why we chose to use a brushless motor and a speed reduction of 7 times. Remarks: We don't consider friction and inefficiency for the sake of simplicity We didn't solve the differential equations as we don't really need to, so we don't take into account time, just the current angle relative to the vertical. References We used the following papers to fact check our calculations: Researchgate: Design and implementation of a self-balancing robot KTH: Reaction Wheel Stabilized Stick","title":"Underlying Physic"},{"location":"building/physics/#underlying-physics","text":"In this section, we will explain the physics behind the balancing robot, and how we used it to design the robot.","title":"Underlying physics"},{"location":"building/physics/#physics-concept","text":"In order to build a functioning balancing robot, it is really important to understand the physics that make it work. In this section, we will address this. The self-balancing capability of our robot relies on the conservation of angular momentum. When the robot tilts, the reaction wheel is accelerated in a controlled manner in order to apply a reactive torque on the system, thus countering the torque caused by gravity. By exerting an opposing force, the reaction wheel helps restore the robot to an upright position. This continuous adjustment and counteraction of tilting forces enable the robot to maintain its balance in real time. We can consider the following simplified model of an inverted pendulum: We can derive the equations of motion of the system using rotational mechanics , which will help us understand what kind of forces we are dealing with. Please check the full development for more details on notation and derivation. Here are some of the important formulas we derived: Torque: $$\\tau_w = I_s\\alpha_s - h_gMgsin(\\phi)$$ Angular acceleration: $$\\alpha_w(\\phi)=\\frac{I_s}{I_w}\\alpha_s - \\frac{h_gMgsin(\\phi)}{I_w}$$ Power: $$P_w = \\tau_w\\omega_w$$ You can find the Graphs of the equations of motion in our Desmos Project , and play around with the parameters to see how they affect the system. We found out in our initial estimations that a quite large output torque is required to stabilize the 2 axis robot with the parts that were available to us, about 2Nm and 25W of mechanical power at least, which is why we chose to use a brushless motor and a speed reduction of 7 times.","title":"Physics concept"},{"location":"building/physics/#remarks","text":"We don't consider friction and inefficiency for the sake of simplicity We didn't solve the differential equations as we don't really need to, so we don't take into account time, just the current angle relative to the vertical.","title":"Remarks:"},{"location":"building/physics/#references","text":"We used the following papers to fact check our calculations: Researchgate: Design and implementation of a self-balancing robot KTH: Reaction Wheel Stabilized Stick","title":"References"},{"location":"building/wiring/","text":"Wiring Instructions The wiring diagram is the following: The following table contains all the connections to the NodeMCU. NodeMCU Pin Connected To D1 SCL MPU6050 D2 SDA MPU6050 D4 TX ESC Left D5 RX ESC Left D6 TX ESC RIGHT D7 RX ESC RIGHT D8 Int Vin 5V ESC 3v3 VCC MPU6050 Notes The D1 pin and the D2 pin are reserved for SCL and SDA of the MPU6050 respectively. The D8 pin is reserved for the interrupt pin on the MPU6050. The MPU6050 is powered through the 3V3 pin on the NodeMCU. The NodeMCU itself is powered by the 5V red cable of the ESC. All the grounds are connected together. For the TX and RX channels on the ESCs, it does not matter to which digital pin they are connected on the NodeMCU. However, note that the pins used must be specified on the code. Both ESCs are powered directly through the battery. There is one ESC per motor and the hall sensors of each motor are connected to each ESC respectively.","title":"Wiring Instructions"},{"location":"building/wiring/#wiring-instructions","text":"The wiring diagram is the following: The following table contains all the connections to the NodeMCU. NodeMCU Pin Connected To D1 SCL MPU6050 D2 SDA MPU6050 D4 TX ESC Left D5 RX ESC Left D6 TX ESC RIGHT D7 RX ESC RIGHT D8 Int Vin 5V ESC 3v3 VCC MPU6050","title":"Wiring Instructions"},{"location":"building/wiring/#notes","text":"The D1 pin and the D2 pin are reserved for SCL and SDA of the MPU6050 respectively. The D8 pin is reserved for the interrupt pin on the MPU6050. The MPU6050 is powered through the 3V3 pin on the NodeMCU. The NodeMCU itself is powered by the 5V red cable of the ESC. All the grounds are connected together. For the TX and RX channels on the ESCs, it does not matter to which digital pin they are connected on the NodeMCU. However, note that the pins used must be specified on the code. Both ESCs are powered directly through the battery. There is one ESC per motor and the hall sensors of each motor are connected to each ESC respectively.","title":"Notes"},{"location":"process/challenges/","text":"Challenges Faced Throughout the eight weeks of working in these project, we faced many challenges and difficulties. In this part of the documentation, we will address these challenges and discuss the solutions we found. The goal is to document the process and provide a small troubleshooting guide. MPU6050 The MPU6050 is cheap accelerometer and gyroscope that is readily available, and it is able to get very precise readings if configured correctly. However, we struggled a lot to get reliable and correct angle measurement from it. It would sometimes start spitting random values for no apparent reason, sometimes the readings just freeze and other times the angle changes on it's own once the motor is spinning. Note that we used the integrated DMP of the mpu6050, as it provides a much more accurate reading and even provides quaternions that can avoid gimbal lock . For each of these problems we pinpointed the problem and found a solution: The loop frequency of the NodeMcu was very slow (see below), so the integrated buffer was overflowing, which is the cause of random values. The mechanical vibrations were causing the accelerometer to fluctuate too much and were interfering with the reading. We added dampeners and attached the mpu with velcros instead of screws to fix the issue The I2C bus of the esp8266 is not very stable , so sometimes is freezes which turned out to be a known issue. We solved it by adding a timout for the bus which restarts it in case it fails. A lot of these MPU6050 chips are made in China at very high volumes, so a good proportion of them don't function properly, so try multiple ones to isolate this if you are having issues. ESP8266 We used the NodeMcu 0.9 for our project, which is excellent for it's cost! It is based on the esp8266 chip, which makes it 10 times less expensive and 10 times faster than other options like the AVR arduino Uno (160Mhz instead of 16Mhz). However, this comes at a cost : stability , predictability and code availability . A lot of code other people used is not compatible with this device, for instance interrupts are handled differently, which forced us to rewrite some existing code. Some libraries were just bad, such as the integrated Servo.h library, which uses blocking code and slows down the whole loop to 50Hz! This is what caused the MPU6050 to act bizarrely and took a lot of time to debug. And finally the I2C bus is unstable which also made the IMU readings unreliable. Here are some of the solutions we implemented over time: Add Schedulers (timers) to run different parts of the code at different times, solving the blocking issue of Servo. Play with the frequency of the I2C bus and timeout for it to be more predictable Overclock to 160Mhz instead of the default 80Mhz To increase the speed of the loop even more, we minimised the number of Serial prints and increased the baud rate to 250000 We tried to squeeze as much performance as possible out of it, and the difference it makes is really impressive, as we do need as much responsiveness as possible. Motor Controller First we got a cheap RC Car sensored ESC from amazon and thought it would do the trick. This was not the case, as these ESC's are not intended for robotics and are not very precise . They are a \"black box\" in a sense that the settings are ambiguous, and we don't know what the curves it uses are for setting the RPM which could be making the system non-linear (no good for our controller). They are also controlled by a standard RC PWM signal (Servo style), which is 50Hz, but we need to update the speed of the motor at a much higher frequency to be able to balance the robot (at least 120Hz), which is not possible with these ESC's. The solution: We got a new controller, the VESC , which is a very powerful and precise controller, which can be controlled by a serial interface (UART) , and can be configured to use a much higher frequency. It is also open source and has a large community, but is twice as expensive . Having a brushless setup means that the controllers must be very expensive to accomplish the level of control we need. A brushed one doesn't need any fancy controller, has constant torque, can be controlled at high frequency and is much cheaper. Heat With great power comes great heat. The motors we used are very powerful and can draw up to 40A each at full power (~450W), which is a lot of current. This means that the motors get very hot, so we can not run them for long periods if the load is too large without damaging them. Solutions: Current is directly proportional to the torque of the motor, so we can reduce the current by reducing the torque. This is what we did by adding a pulley reduction to the motors, which reduced the torque by a factor of 7, which means that the current is also reduced by a factor of 7 and so is the speed. This means that the motors can run for longer periods without overheating. We also added a computer fan to cool down the motors, which is effective and can be turned on and off with a switch. Tuning For three whole weeks, we did not realize that we were using the PID controller library wrongly. Setting only a proportional gain wasn't doing what we expected, which was to increase the output of the PID controller as the error increased and oscillate around the set-point . Instead, the output was oscillating around another seemingly random value. After a lot of debugging and trying custom PID controllers, we were able to fix it: Use the flag P_ON_E which means proportional on error instead of the default P_ON_M which is proportional on measurement. This means that the error is used to calculate the proportional gain instead of the measurement, which is what we want. Reset the PID controller after changing the set-point while running so that is completely forgets the previous state and starts from scratch. Tune the PID controller with the Ziegler-Nichols method , which is a simple and effective method to tune PID controllers. Collaboration For many of us, this was the first time working on such a big project and with so many team members. As such, collaboration was a a significant challenge right from the beginning. All the team members were really motivated and invested in the project. Hence, when there were different opinions about how to do something, it was often hard to reconcile the different viewpoints. Often, when the opinions differed, they led to significant internal discussions. A notable example is what motors we should use. Some of us believed that a brushed would be the best option, while others believed that a brushless one would be more adequate. In the end, we often solved such conflicts by testing both options and finding which would be \"objectively\" the best. It is interesting to reflect back on this project, since a considerable part of the difficulty was not conceiving the robot in itself, but the collaboration. This is why, not only did we acquire more knowledge, practical and technical skills, but we also learned to collaborate. We found out that collaboration is a mix between stating what you as individual wants to do, while keeping in mind what others want to do, and finally discussing a solution that suits both parties. It is for this reason that we are happy to have embarked on such a project, since we strongly believe it will help us in our future professional and personal lives.","title":"Challenges Faced"},{"location":"process/challenges/#challenges-faced","text":"Throughout the eight weeks of working in these project, we faced many challenges and difficulties. In this part of the documentation, we will address these challenges and discuss the solutions we found. The goal is to document the process and provide a small troubleshooting guide.","title":"Challenges Faced"},{"location":"process/challenges/#mpu6050","text":"The MPU6050 is cheap accelerometer and gyroscope that is readily available, and it is able to get very precise readings if configured correctly. However, we struggled a lot to get reliable and correct angle measurement from it. It would sometimes start spitting random values for no apparent reason, sometimes the readings just freeze and other times the angle changes on it's own once the motor is spinning. Note that we used the integrated DMP of the mpu6050, as it provides a much more accurate reading and even provides quaternions that can avoid gimbal lock . For each of these problems we pinpointed the problem and found a solution: The loop frequency of the NodeMcu was very slow (see below), so the integrated buffer was overflowing, which is the cause of random values. The mechanical vibrations were causing the accelerometer to fluctuate too much and were interfering with the reading. We added dampeners and attached the mpu with velcros instead of screws to fix the issue The I2C bus of the esp8266 is not very stable , so sometimes is freezes which turned out to be a known issue. We solved it by adding a timout for the bus which restarts it in case it fails. A lot of these MPU6050 chips are made in China at very high volumes, so a good proportion of them don't function properly, so try multiple ones to isolate this if you are having issues.","title":"MPU6050"},{"location":"process/challenges/#esp8266","text":"We used the NodeMcu 0.9 for our project, which is excellent for it's cost! It is based on the esp8266 chip, which makes it 10 times less expensive and 10 times faster than other options like the AVR arduino Uno (160Mhz instead of 16Mhz). However, this comes at a cost : stability , predictability and code availability . A lot of code other people used is not compatible with this device, for instance interrupts are handled differently, which forced us to rewrite some existing code. Some libraries were just bad, such as the integrated Servo.h library, which uses blocking code and slows down the whole loop to 50Hz! This is what caused the MPU6050 to act bizarrely and took a lot of time to debug. And finally the I2C bus is unstable which also made the IMU readings unreliable. Here are some of the solutions we implemented over time: Add Schedulers (timers) to run different parts of the code at different times, solving the blocking issue of Servo. Play with the frequency of the I2C bus and timeout for it to be more predictable Overclock to 160Mhz instead of the default 80Mhz To increase the speed of the loop even more, we minimised the number of Serial prints and increased the baud rate to 250000 We tried to squeeze as much performance as possible out of it, and the difference it makes is really impressive, as we do need as much responsiveness as possible.","title":"ESP8266"},{"location":"process/challenges/#motor-controller","text":"First we got a cheap RC Car sensored ESC from amazon and thought it would do the trick. This was not the case, as these ESC's are not intended for robotics and are not very precise . They are a \"black box\" in a sense that the settings are ambiguous, and we don't know what the curves it uses are for setting the RPM which could be making the system non-linear (no good for our controller). They are also controlled by a standard RC PWM signal (Servo style), which is 50Hz, but we need to update the speed of the motor at a much higher frequency to be able to balance the robot (at least 120Hz), which is not possible with these ESC's. The solution: We got a new controller, the VESC , which is a very powerful and precise controller, which can be controlled by a serial interface (UART) , and can be configured to use a much higher frequency. It is also open source and has a large community, but is twice as expensive . Having a brushless setup means that the controllers must be very expensive to accomplish the level of control we need. A brushed one doesn't need any fancy controller, has constant torque, can be controlled at high frequency and is much cheaper.","title":"Motor Controller"},{"location":"process/challenges/#heat","text":"With great power comes great heat. The motors we used are very powerful and can draw up to 40A each at full power (~450W), which is a lot of current. This means that the motors get very hot, so we can not run them for long periods if the load is too large without damaging them. Solutions: Current is directly proportional to the torque of the motor, so we can reduce the current by reducing the torque. This is what we did by adding a pulley reduction to the motors, which reduced the torque by a factor of 7, which means that the current is also reduced by a factor of 7 and so is the speed. This means that the motors can run for longer periods without overheating. We also added a computer fan to cool down the motors, which is effective and can be turned on and off with a switch.","title":"Heat"},{"location":"process/challenges/#tuning","text":"For three whole weeks, we did not realize that we were using the PID controller library wrongly. Setting only a proportional gain wasn't doing what we expected, which was to increase the output of the PID controller as the error increased and oscillate around the set-point . Instead, the output was oscillating around another seemingly random value. After a lot of debugging and trying custom PID controllers, we were able to fix it: Use the flag P_ON_E which means proportional on error instead of the default P_ON_M which is proportional on measurement. This means that the error is used to calculate the proportional gain instead of the measurement, which is what we want. Reset the PID controller after changing the set-point while running so that is completely forgets the previous state and starts from scratch. Tune the PID controller with the Ziegler-Nichols method , which is a simple and effective method to tune PID controllers.","title":"Tuning"},{"location":"process/challenges/#collaboration","text":"For many of us, this was the first time working on such a big project and with so many team members. As such, collaboration was a a significant challenge right from the beginning. All the team members were really motivated and invested in the project. Hence, when there were different opinions about how to do something, it was often hard to reconcile the different viewpoints. Often, when the opinions differed, they led to significant internal discussions. A notable example is what motors we should use. Some of us believed that a brushed would be the best option, while others believed that a brushless one would be more adequate. In the end, we often solved such conflicts by testing both options and finding which would be \"objectively\" the best. It is interesting to reflect back on this project, since a considerable part of the difficulty was not conceiving the robot in itself, but the collaboration. This is why, not only did we acquire more knowledge, practical and technical skills, but we also learned to collaborate. We found out that collaboration is a mix between stating what you as individual wants to do, while keeping in mind what others want to do, and finally discussing a solution that suits both parties. It is for this reason that we are happy to have embarked on such a project, since we strongly believe it will help us in our future professional and personal lives.","title":"Collaboration"},{"location":"process/improvements/","text":"Future Improvements In the end, due to a lack of time, we did not manage to make the 2 Axes Model balance. Many challenges arose when finally tuning that model. However, we strongly believe that with more time, we could have gotten a very well-working model. These are the following improvements we wish we could have done to this model: Since the robot has now more freedom to move around, the turning wheels are exerting a torque around the feet that hold the model and thus it starts spinning. As such, we could implement another feature to the controller to counteract the spinning. It is very difficult to understand what effect on the balancing each wheel is having. Hence, we think that a quick-swap mechanism that allows us to mount the robot to a testing bench, constraining one axis to tune it separately, would help enormously. The feet it stands on, made out of a combination of hard filament and flexible filament, is too soft. This makes the balancing harder. In order to solve this, we could design a better, stronger and wider feet that is able to take the whole weight of the robot.","title":"Future Improvements"},{"location":"process/improvements/#future-improvements","text":"In the end, due to a lack of time, we did not manage to make the 2 Axes Model balance. Many challenges arose when finally tuning that model. However, we strongly believe that with more time, we could have gotten a very well-working model. These are the following improvements we wish we could have done to this model: Since the robot has now more freedom to move around, the turning wheels are exerting a torque around the feet that hold the model and thus it starts spinning. As such, we could implement another feature to the controller to counteract the spinning. It is very difficult to understand what effect on the balancing each wheel is having. Hence, we think that a quick-swap mechanism that allows us to mount the robot to a testing bench, constraining one axis to tune it separately, would help enormously. The feet it stands on, made out of a combination of hard filament and flexible filament, is too soft. This makes the balancing harder. In order to solve this, we could design a better, stronger and wider feet that is able to take the whole weight of the robot.","title":"Future Improvements"},{"location":"process/prototypes/","text":"Prototypes Throughout the process of designing the robot, we iterated through several prototypes until we got the final products. In this section, we will show some of the most important prototypes and briefly discuss them. One Axis Balancing Robot v1 This was the first prototype we did for the robot. Back then, we did not even have the final components, so we were testing with some components the professor gave us, among them, a brushless DC motor and a generic ESC. One Axis Balancing Robot v2 The design for this robot is the one we used for the final version of the one axis one. It consists of a motor mounted on the base, a small pulley attached to it, a bigger pulley on top and a timing belt joining both. The design of the wheel is much sturdier and elegant. We tested many different reductions for the wheel until we settled with a 7 time reduction. After a small accident, we decided to add a protection for the wheel made out of MDF and 3D printed parts. It also has a handle on top to make it easier to hold it and to fix the MPU6050. Two Axes Balancing Robot v1 The design of this robot is quite similar to the before one, but using a bigger plate to hold two motors, ESCs and wheels. Alternative Design A couple weeks before the deadline, while some team members worked on the One Axis v2 , other team members decided to try a smaller version of the balancing robot. This version uses a small brushed motor with an integrated gear reduction, laser cut MDF body and wheel. Although it managed to stay balanced for a couple of seconds, this prototype was pretty rough and a better design should have been made to get it to properly work. However, while working on it, the other team members managed to make the One Axis v2 work. So, this was put aside.","title":"Prototype History"},{"location":"process/prototypes/#prototypes","text":"Throughout the process of designing the robot, we iterated through several prototypes until we got the final products. In this section, we will show some of the most important prototypes and briefly discuss them.","title":"Prototypes"},{"location":"process/prototypes/#one-axis-balancing-robot-v1","text":"This was the first prototype we did for the robot. Back then, we did not even have the final components, so we were testing with some components the professor gave us, among them, a brushless DC motor and a generic ESC.","title":"One Axis Balancing Robot v1"},{"location":"process/prototypes/#one-axis-balancing-robot-v2","text":"The design for this robot is the one we used for the final version of the one axis one. It consists of a motor mounted on the base, a small pulley attached to it, a bigger pulley on top and a timing belt joining both. The design of the wheel is much sturdier and elegant. We tested many different reductions for the wheel until we settled with a 7 time reduction. After a small accident, we decided to add a protection for the wheel made out of MDF and 3D printed parts. It also has a handle on top to make it easier to hold it and to fix the MPU6050.","title":"One Axis Balancing Robot v2"},{"location":"process/prototypes/#two-axes-balancing-robot-v1","text":"The design of this robot is quite similar to the before one, but using a bigger plate to hold two motors, ESCs and wheels.","title":"Two Axes Balancing Robot v1"},{"location":"process/prototypes/#alternative-design","text":"A couple weeks before the deadline, while some team members worked on the One Axis v2 , other team members decided to try a smaller version of the balancing robot. This version uses a small brushed motor with an integrated gear reduction, laser cut MDF body and wheel. Although it managed to stay balanced for a couple of seconds, this prototype was pretty rough and a better design should have been made to get it to properly work. However, while working on it, the other team members managed to make the One Axis v2 work. So, this was put aside.","title":"Alternative Design"},{"location":"process/thanks/","text":"Thanks We want to warmly thanks Professor Christoph Koch, Federico Stella and the rest of the CS-358 TAs for the support and guidance they provided throughout the semester. Also, many thanks to the staff of the SPOT. Without the help from all of this people, this project would have never come to fruition. The Team being happy for the robot working just a few days before the deadline. The Team Working Hard \ud83e\udd13 The Dream Team but incomplete","title":"Thanks"},{"location":"process/thanks/#thanks","text":"We want to warmly thanks Professor Christoph Koch, Federico Stella and the rest of the CS-358 TAs for the support and guidance they provided throughout the semester. Also, many thanks to the staff of the SPOT. Without the help from all of this people, this project would have never come to fruition. The Team being happy for the robot working just a few days before the deadline. The Team Working Hard \ud83e\udd13 The Dream Team but incomplete","title":"Thanks"},{"location":"software/controller/","text":"Controller Explanation To have a better ease of use and comprehension of the software, it is important to understand how the angular speed of the wheel is controlled. PID Controller To control the speed of rotation of the wheel, we use control loop called Proportional-Integral-Derivative Controller or PID Controller for short. In the image below, we can see an overview of this controller: $r(t) =$ Setpoint (SP) $u(t) =$ Control Variable $y(t) =$ Process Variable $e(t) =$ Error Variable Such a controller works in the following way. First, a setpoint (SP) is chosen. The SP is the desired position that the robot should achieve. In our case, it would correspond to a small roll angle. If the angle is small, it means that the robot is in balance. Note that in an ideal world, the SP would be $0\u00b0$. However, since the weight of the robot is not perfectly distributed, the $r(t) \\in [-5^{\\circ}, 5^{\\circ}]$. Later, we will also explain how and why we must adjust the SP dynamically to achieve greater stability. Then, the controller computes the error variable : $$e(t) = r(t) - y(t)$$ The error represents how \"far\" the robot is to the SP. After that, the error variable is passed through three different channels: proportional (P), integral (I) and derivative (D) . Each channel possess a so-called gain : $K_{p}$, $K_{i}$ and $K_{d}$ respectively. These gains are constants defined by the user of the PID controller to determine the effect or \"weight\" of each channel on the control variable $u(t)$. By doing so, the desired behavior is achieved (see the Tuning Guide ). In the P channel, the error variable is simply multiplied by the constant $K_{p}$. In the I channel, the error is integrated w.r.t. time and then multiplied by $K_{i}$. Finally, in the D channel, the error is derived w.r.t. time and then multiplied by $K_{d}$. Thus, the control variable can be expressed as: $$u(t) = K_\\text{p} e(t) + K_\\text{i} \\int_0^t e(\\tau) \\,\\mathrm{d}\\tau + K_\\text{d} \\frac{\\mathrm{d}e(t)}{\\mathrm{d}t}$$ The control variable is then fed to the motor in the form of a PWM signal or the RPM at which it should spin. Finally, the process variable $y(t)$, in our case, the newly measured angle, is fed back and the new error variable $e(t)$ is computed. Then, the loop begins again. Understanding the Effect of Each Channel Let us examine the effect of each channel to understand how they may help us to achieve a robot that balances itself. Suppose that we are only using the proportional path , that is $K_{i}$ and $K_{d}$ are set to zero: $$u(t) = K_{p}e(t)$$ Suppose too that the motor must accelerate to a speed of 100 RPM to counteract the torque exerted by gravity on the robot. Then, by increasing the $K_{p}$, we can decrease the error: Error $e(t)$ Gain $K_{p}$ RPM $u(t)$ 50 2 100 20 5 100 10 10 100 1 100 100 On a first glance, this seems enough. However, looking closely, we notice that no matter how big the $K_{p}$ is set to, there will always be a small error. This particular type of error is often called steady state error , and it is the integral channel purpose to eliminate. Let us suppose that we set $K_{p} = 20$ and we reduced the error to $e(t) = 5^{\\circ}$: Although the motor is already spinning at 100 RPM, the error $e(t)$ has not yet been reduced to $0^{\\circ}$. This is where the integral channel comes in. Suppose now that the motor holds its position for a few milliseconds with an error of $e(t) = 5^{\\circ}$. The integral channel will integrate this constant error w.r.t time and continue adding to the control variable $u(t)$. Thus, the integral channel finishes correcting any error that the proportional channel did not correct. Sometimes, it can happen that although the robot is very close to the SP, the integrator still has a positive value. In order to decrease this value, it must overshoot beyond the SP to generate a negative error. This causes oscillations on the robot, since it needs to constantly overshoot to reduce the integral term. Hence, the final channel comes into play: the derivative channel . As the name suggests, the channel derives the error w.r.t time. Thus, the controller gains some insight on the rate of change of the error and is then able to \"predict\" the motion of the robot. As the robot approaches the SP, the error decreases and the derivative is then negative. Therefore, when adding all of the channels together, the derivative term will counteract the other channels to adjust the rotational speed in advance. In brief, the proportional channel will try to close the gap between the SP and the current position; the integral channel will fix the error that the proportional did not manage to; and finally, the derivative path will counterbalance the other two to help it stabilize faster. In conjunction, the three channels work together to keep the robot in balance. Dynamic Shifting of the Setpoint Shift the setpoint automatically in by +-0.5 using an LQR algorithm to reduce overshoot and make the system more stable. The algorithm is as follows: The input and output are averaged over a window of 100 and 50 respectively The output is then converted to a logarithmic scale and constrained The input average is constrained to be within +-0.5 of the original setpoint The setpoint is then calculated by subtracting a multiple of the output from the input and constraining it This will cause the setpoint to want to drift towards the average tilt angle of the system (setpoint), however the output will try to counteract this drift by pushing the setpoint in the opposite direction (penalizing a high output). Meaning the higher the output, the more the setpoint will be pushed in the opposite direction, and vice versa, causing a dynamic equilibrium towards the real setpoint.","title":"Controller Explanation"},{"location":"software/controller/#controller-explanation","text":"To have a better ease of use and comprehension of the software, it is important to understand how the angular speed of the wheel is controlled.","title":"Controller Explanation"},{"location":"software/controller/#pid-controller","text":"To control the speed of rotation of the wheel, we use control loop called Proportional-Integral-Derivative Controller or PID Controller for short. In the image below, we can see an overview of this controller: $r(t) =$ Setpoint (SP) $u(t) =$ Control Variable $y(t) =$ Process Variable $e(t) =$ Error Variable Such a controller works in the following way. First, a setpoint (SP) is chosen. The SP is the desired position that the robot should achieve. In our case, it would correspond to a small roll angle. If the angle is small, it means that the robot is in balance. Note that in an ideal world, the SP would be $0\u00b0$. However, since the weight of the robot is not perfectly distributed, the $r(t) \\in [-5^{\\circ}, 5^{\\circ}]$. Later, we will also explain how and why we must adjust the SP dynamically to achieve greater stability. Then, the controller computes the error variable : $$e(t) = r(t) - y(t)$$ The error represents how \"far\" the robot is to the SP. After that, the error variable is passed through three different channels: proportional (P), integral (I) and derivative (D) . Each channel possess a so-called gain : $K_{p}$, $K_{i}$ and $K_{d}$ respectively. These gains are constants defined by the user of the PID controller to determine the effect or \"weight\" of each channel on the control variable $u(t)$. By doing so, the desired behavior is achieved (see the Tuning Guide ). In the P channel, the error variable is simply multiplied by the constant $K_{p}$. In the I channel, the error is integrated w.r.t. time and then multiplied by $K_{i}$. Finally, in the D channel, the error is derived w.r.t. time and then multiplied by $K_{d}$. Thus, the control variable can be expressed as: $$u(t) = K_\\text{p} e(t) + K_\\text{i} \\int_0^t e(\\tau) \\,\\mathrm{d}\\tau + K_\\text{d} \\frac{\\mathrm{d}e(t)}{\\mathrm{d}t}$$ The control variable is then fed to the motor in the form of a PWM signal or the RPM at which it should spin. Finally, the process variable $y(t)$, in our case, the newly measured angle, is fed back and the new error variable $e(t)$ is computed. Then, the loop begins again.","title":"PID Controller"},{"location":"software/controller/#understanding-the-effect-of-each-channel","text":"Let us examine the effect of each channel to understand how they may help us to achieve a robot that balances itself. Suppose that we are only using the proportional path , that is $K_{i}$ and $K_{d}$ are set to zero: $$u(t) = K_{p}e(t)$$ Suppose too that the motor must accelerate to a speed of 100 RPM to counteract the torque exerted by gravity on the robot. Then, by increasing the $K_{p}$, we can decrease the error: Error $e(t)$ Gain $K_{p}$ RPM $u(t)$ 50 2 100 20 5 100 10 10 100 1 100 100 On a first glance, this seems enough. However, looking closely, we notice that no matter how big the $K_{p}$ is set to, there will always be a small error. This particular type of error is often called steady state error , and it is the integral channel purpose to eliminate. Let us suppose that we set $K_{p} = 20$ and we reduced the error to $e(t) = 5^{\\circ}$: Although the motor is already spinning at 100 RPM, the error $e(t)$ has not yet been reduced to $0^{\\circ}$. This is where the integral channel comes in. Suppose now that the motor holds its position for a few milliseconds with an error of $e(t) = 5^{\\circ}$. The integral channel will integrate this constant error w.r.t time and continue adding to the control variable $u(t)$. Thus, the integral channel finishes correcting any error that the proportional channel did not correct. Sometimes, it can happen that although the robot is very close to the SP, the integrator still has a positive value. In order to decrease this value, it must overshoot beyond the SP to generate a negative error. This causes oscillations on the robot, since it needs to constantly overshoot to reduce the integral term. Hence, the final channel comes into play: the derivative channel . As the name suggests, the channel derives the error w.r.t time. Thus, the controller gains some insight on the rate of change of the error and is then able to \"predict\" the motion of the robot. As the robot approaches the SP, the error decreases and the derivative is then negative. Therefore, when adding all of the channels together, the derivative term will counteract the other channels to adjust the rotational speed in advance. In brief, the proportional channel will try to close the gap between the SP and the current position; the integral channel will fix the error that the proportional did not manage to; and finally, the derivative path will counterbalance the other two to help it stabilize faster. In conjunction, the three channels work together to keep the robot in balance.","title":"Understanding the Effect of Each Channel"},{"location":"software/controller/#dynamic-shifting-of-the-setpoint","text":"Shift the setpoint automatically in by +-0.5 using an LQR algorithm to reduce overshoot and make the system more stable. The algorithm is as follows: The input and output are averaged over a window of 100 and 50 respectively The output is then converted to a logarithmic scale and constrained The input average is constrained to be within +-0.5 of the original setpoint The setpoint is then calculated by subtracting a multiple of the output from the input and constraining it This will cause the setpoint to want to drift towards the average tilt angle of the system (setpoint), however the output will try to counteract this drift by pushing the setpoint in the opposite direction (penalizing a high output). Meaning the higher the output, the more the setpoint will be pushed in the opposite direction, and vice versa, causing a dynamic equilibrium towards the real setpoint.","title":"Dynamic Shifting of the Setpoint"},{"location":"software/tuning/","text":"Tuning Guide In this section we will briefly discuss the method we used to tune the PID controller. It is very helpful to understand how the PID controller works, and for that we recommend reading the controller explanation . Manual Tuning Most of the part of the tuning was done manually. Be aware that tuning is a very tedious and time-consuming process. Some say, modern Sisyphus is not pushing a rock uphill, but tuning a PID controller for eternity. The method we recommend is the one found in Wikipedia. As a general rule of thumb, one parameter should be modified at a time with small increments. However, sometimes following a hunch and changing multiple parameters at once proves useful. Start by only using the proportional channel and increase the value until the responsiveness of the robot is fast enough. Normally, if you let go the robot at this point, it will start oscillating and then fall. Continue by using the integral channel too. This will increase the responsiveness and the robot will be able to better correct the error. At the end of this step, the robot should be able to balance, but it will keep oscillating. Finally, start using the derivative path. The goal of the derivative path is to reduce the oscillations of the robot and help it stabilize around the setpoint.","title":"Tuning Guide"},{"location":"software/tuning/#tuning-guide","text":"In this section we will briefly discuss the method we used to tune the PID controller. It is very helpful to understand how the PID controller works, and for that we recommend reading the controller explanation .","title":"Tuning Guide"},{"location":"software/tuning/#manual-tuning","text":"Most of the part of the tuning was done manually. Be aware that tuning is a very tedious and time-consuming process. Some say, modern Sisyphus is not pushing a rock uphill, but tuning a PID controller for eternity. The method we recommend is the one found in Wikipedia. As a general rule of thumb, one parameter should be modified at a time with small increments. However, sometimes following a hunch and changing multiple parameters at once proves useful. Start by only using the proportional channel and increase the value until the responsiveness of the robot is fast enough. Normally, if you let go the robot at this point, it will start oscillating and then fall. Continue by using the integral channel too. This will increase the responsiveness and the robot will be able to better correct the error. At the end of this step, the robot should be able to balance, but it will keep oscillating. Finally, start using the derivative path. The goal of the derivative path is to reduce the oscillations of the robot and help it stabilize around the setpoint.","title":"Manual Tuning"},{"location":"software/usage/","text":"Software Explanation and Usage The software structure is simple. There is a folder named classes which contains all the c++ classes used in the main Self_balancing.ino file. We decided to use classes to improve the reusability and modularity of the code. Although we will briefly discuss each class here, we invite you to read the code to have a better understanding of it. Self_balancing.ino This is the main file that combines together all the other classes. It setups the MQTT communication, namely retrieving the parameters from the web app. It also loops over the finite state machine (FSM). FSM.cpp This class models a FSM for the balancing robot. It has different states it can be set to, in order to facilitate the control of the robot. The most important function in this class is called loop() . It is in charge of updating the FSM. Most importantly, it calls the computation of the PID output. The different states are: Disabled: If the robot has fallen beyond a certain angle, it will turn off the motors to avoid any harm to us or the wheels. Balance Debug: Similar to Balance , but it will print useful information. Tuning: Used to calibrating the MPU6050's offsets. Gyro.cpp This class is used to interface with the MPU6050 and retrieve the roll, pitch and yaw angles. mpuCalibration.cpp This is a very useful class to calibrate the MPU6050. Every time the MPU6050's angle readings appear incorrect, it means it must be calibrated. This class is therefore used to find the offsets for the MPU6050. mqttClient.cpp This class is used for the MQTT connection and messages. We used the MQTT protocol to update the tunings of the robot, like the gains and the setpoint, without having to reupload the code. MyPIDController This was a class we created while trying to get the first prototype to work. It is an implementation of a PID Controller following Phil\u2019s Lab video , but without using any external libraries. pidautotuner.cpp This is another class we created while trying to get the prototype to work. We were having lots of problems with the tuning of the gains, so we tried to use an auto-tuner. In the end, the problem was that the ESC. Once we changed that, it was much easier to find the parameters manually. PIDControl.cpp This is a wrapper class for the excellent PID library created by Brett Beauregard. This is the one we ended up using, as it has many useful features as integration clamping, derivative-on-measurement and many more. See this link to find out more. Scheduler.cpp The scheduler is a sort of timer that allows us to run different parts of the code at different frequencies. VESC.cpp This class is used to interface with the FSESC.","title":"Software"},{"location":"software/usage/#software-explanation-and-usage","text":"The software structure is simple. There is a folder named classes which contains all the c++ classes used in the main Self_balancing.ino file. We decided to use classes to improve the reusability and modularity of the code. Although we will briefly discuss each class here, we invite you to read the code to have a better understanding of it.","title":"Software Explanation and Usage"},{"location":"software/usage/#self_balancingino","text":"This is the main file that combines together all the other classes. It setups the MQTT communication, namely retrieving the parameters from the web app. It also loops over the finite state machine (FSM).","title":"Self_balancing.ino"},{"location":"software/usage/#fsmcpp","text":"This class models a FSM for the balancing robot. It has different states it can be set to, in order to facilitate the control of the robot. The most important function in this class is called loop() . It is in charge of updating the FSM. Most importantly, it calls the computation of the PID output. The different states are: Disabled: If the robot has fallen beyond a certain angle, it will turn off the motors to avoid any harm to us or the wheels. Balance Debug: Similar to Balance , but it will print useful information. Tuning: Used to calibrating the MPU6050's offsets.","title":"FSM.cpp"},{"location":"software/usage/#gyrocpp","text":"This class is used to interface with the MPU6050 and retrieve the roll, pitch and yaw angles.","title":"Gyro.cpp"},{"location":"software/usage/#mpucalibrationcpp","text":"This is a very useful class to calibrate the MPU6050. Every time the MPU6050's angle readings appear incorrect, it means it must be calibrated. This class is therefore used to find the offsets for the MPU6050.","title":"mpuCalibration.cpp"},{"location":"software/usage/#mqttclientcpp","text":"This class is used for the MQTT connection and messages. We used the MQTT protocol to update the tunings of the robot, like the gains and the setpoint, without having to reupload the code.","title":"mqttClient.cpp"},{"location":"software/usage/#mypidcontroller","text":"This was a class we created while trying to get the first prototype to work. It is an implementation of a PID Controller following Phil\u2019s Lab video , but without using any external libraries.","title":"MyPIDController"},{"location":"software/usage/#pidautotunercpp","text":"This is another class we created while trying to get the prototype to work. We were having lots of problems with the tuning of the gains, so we tried to use an auto-tuner. In the end, the problem was that the ESC. Once we changed that, it was much easier to find the parameters manually.","title":"pidautotuner.cpp"},{"location":"software/usage/#pidcontrolcpp","text":"This is a wrapper class for the excellent PID library created by Brett Beauregard. This is the one we ended up using, as it has many useful features as integration clamping, derivative-on-measurement and many more. See this link to find out more.","title":"PIDControl.cpp"},{"location":"software/usage/#schedulercpp","text":"The scheduler is a sort of timer that allows us to run different parts of the code at different frequencies.","title":"Scheduler.cpp"},{"location":"software/usage/#vesccpp","text":"This class is used to interface with the FSESC.","title":"VESC.cpp"},{"location":"software/webapp/","text":"Web app We built a web app that would act as a tool to rapidly try new PID gains and change the setpoint, by sending them to the Arduino via an MQTT broker. It can be found here We can read the current values, flash new ones, change them easily with a scroll wheel at different increments and get confirmation when they are updated. Is is built with Vue and Nodejs, and is hosted on our server, so it can be accessed easily, but can be run locally. Github repo: mit-unicycle/web_app","title":"Web App"},{"location":"software/webapp/#web-app","text":"We built a web app that would act as a tool to rapidly try new PID gains and change the setpoint, by sending them to the Arduino via an MQTT broker. It can be found here We can read the current values, flash new ones, change them easily with a scroll wheel at different increments and get confirmation when they are updated. Is is built with Vue and Nodejs, and is hosted on our server, so it can be accessed easily, but can be run locally. Github repo: mit-unicycle/web_app","title":"Web app"}]}